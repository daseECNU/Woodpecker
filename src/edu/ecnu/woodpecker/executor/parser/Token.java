/* Generated By:JavaCC: Do not edit this line. Token.java Version 5.0 */
/* JavaCCOptions:TOKEN_EXTENDS=,KEEP_LINE_COL=null,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package edu.ecnu.woodpecker.executor.parser;

/**
 * Describes the input token stream.
 */

public class Token implements java.io.Serializable
{

    /**
     * The version identifier for this Serializable class. Increment only if the
     * <i>serialized</i> form of the class changes.
     */
    private static final long serialVersionUID = 1L;

    /**
     * An integer that describes the kind of this token. This numbering system is
     * determined by JavaCCParser, and a table of these numbers is stored in the file
     * ...Constants.java.
     */
    public int kind;

    /** The line number of the first character of this Token. */
    public int beginLine;
    /** The column number of the first character of this Token. */
    public int beginColumn;
    /** The line number of the last character of this Token. */
    public int endLine;
    /** The column number of the last character of this Token. */
    public int endColumn;

    /**
     * The string image of the token.
     */
    public String image;

    /**
     * A reference to the next regular (non-special) token from the input stream. If this
     * is the last token from the input stream, or if the token manager has not read
     * tokens beyond this one, this field is set to null. This is true only if this token
     * is also a regular token. Otherwise, see below for a description of the contents of
     * this field.
     */
    public Token next;

    /**
     * This field is used to access special tokens that occur prior to this token, but
     * after the immediately preceding regular (non-special) token. If there are no such
     * special tokens, this field is set to null. When there are more than one such
     * special token, this field refers to the last of these special tokens, which in turn
     * refers to the next previous special token through its specialToken field, and so on
     * until the first special token (whose specialToken field is null). The next fields
     * of special tokens refer to other special tokens that immediately follow it (without
     * an intervening regular token). If there is no such token, this field is null.
     */
    public Token specialToken;

    /**
     * 此函数只有变量声明或赋值时才会使用，所以只需考虑 int, float, double, String, char, boolean等基本数据类型 TODO
     * 
     * @return 根据值类型，返回相应的值
     */
    public Object getValue() throws Exception
    {
        // Token的值是10进制整型
        if (image.matches("-?[1-9]([0-9])*"))
        {
            try
            {
                return Integer.parseInt(image);
            }
            catch (Exception e1)
            {
                // 超过int范围
                try
                {
                    return Long.parseLong(image);
                }
                catch (Exception e2)
                {
                    // 超过long范围，记日志，给个错误，说此值超过限度，此case直接错误
                    // TODO
                    throw new Exception();
                }
            }
        }

        // Token的值是16进制整型
        if (image.matches("-?0[x,X]([0-9,a-f,A-F])+"))
        {
            String value = image.substring(2);
            try
            {
                return Integer.parseInt(value, 16);
            }
            catch (Exception e1)
            {
                // 超过int范围
                try
                {
                    return Long.parseLong(value, 16);
                }
                catch (Exception e2)
                {
                    // 超过long范围，记日志，给个错误，说此值超过限度，此case直接错误
                    // TODO
                    throw new Exception();
                }
            }
        }

        // Token的值是8进制整型
        if (image.matches("-?[1-9]([0-9])*"))
        {
            try
            {
                return Integer.parseInt(image, 8);
            }
            catch (Exception e1)
            {
                // 超过int范围
                try
                {
                    return Long.parseLong(image, 8);
                }
                catch (Exception e2)
                {
                    // 超过long范围，记日志，给个错误，说此值超过限度，此case直接错误
                    // TODO
                    throw new Exception();
                }
            }
        }

        // Token的值是float
        if (image.matches("-?([0-9])+\\.([0-9])*([f,F])?"))
        {
            try
            {
                return Float.parseFloat(image);
            }
            catch (Exception e)
            {
                // 超出float范围，记日志，给个错误，说此值超过限度，此case直接错误
                // TODO
                throw new Exception();
            }
        }

        // Token的值是double
        if (image.matches("-?([0-9])+\\.([0-9])*([d,D])?"))
        {
            try
            {
                return Double.parseDouble(image);
            }
            catch (Exception e)
            {
                // 超出double范围，记日志，给个错误，说此值超过限度，此case直接错误
                // TODO
                throw new Exception();
            }
        }

        // Token的值是boolean
        if (image.equals("true") || image.equals("false"))
        {
            try
            {
                return Boolean.parseBoolean(image);
            }
            catch (Exception e)
            {
                // 记日志，给个错误，说格式有错，此case直接错误 TODO
                throw new Exception();
            }
        }

        // Token的值是char
        if (image.matches("'\\p{Graph}'"))
        {
            try
            {
                return image.charAt(1);
            }
            catch (Exception e)
            {
                // 记日志，给个错误，说格式有错，此case直接错误 TODO
                throw new Exception();
            }
        }

        // Token的值是String，顺便去掉双引号
        return image.substring(1, image.length() - 1);
    }

    /**
     * No-argument constructor
     */
    public Token()
    {
    }

    /**
     * Constructs a new token for the specified Image.
     */
    public Token(int kind)
    {
        this(kind, null);
    }

    /**
     * Constructs a new token for the specified Image and Kind.
     */
    public Token(int kind, String image)
    {
        this.kind = kind;
        this.image = image;
    }

    /**
     * Returns the image.
     */
    public String toString()
    {
        return image;
    }

    /**
     * Returns a new Token object, by default. However, if you want, you can create and
     * return subclass objects based on the value of ofKind. Simply add the cases to the
     * switch for all those special cases. For example, if you have a subclass of Token
     * called IDToken that you want to create if ofKind is ID, simply add something like :
     *
     * case MyParserConstants.ID : return new IDToken(ofKind, image);
     *
     * to the following switch statement. Then you can cast matchedToken variable to the
     * appropriate type and use sit in your lexical actions.
     */
    public static Token newToken(int ofKind, String image)
    {
        switch (ofKind)
        {
        default:
            return new Token(ofKind, image);
        }
    }

    public static Token newToken(int ofKind)
    {
        return newToken(ofKind, null);
    }

    /**
     * 对Token中的image字符串的指定位置前插入字符串，如index为0则在最前面插入
     * 
     * @param index
     * @param partString
     */
    public void add(int index, String partString) throws Exception
    {
        if (index < 0 || index > image.length())
        {
            throw new Exception("index isn't in the range of image string");
        }
        String left = image.substring(0, index).concat(partString);
        String right = image.substring(index);
        image = left.concat(right);
    }

}
/* JavaCC - OriginalChecksum=b635cb9811409091c69c1a9365f4d9b3 (do not edit this line) */
